import json
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier

ALL_PERMISSIONS = open('permissions.txt', 'r').readlines()
ALL_OPECODES = []
ALL_STRINGS = []


def get_permission_matrix(permissions):
    # print(str(datarow['Package name']))
    perm_vector = np.zeros(len(ALL_PERMISSIONS))
    print(perm_vector.shape)
    for permission in permissions:
        for i in range(len(perm_vector)):
            if ALL_PERMISSIONS[i].strip() == permission:
                # print('Got permission')
                perm_vector[i] = 1
            else:
                perm_vector[i] = 0

    # print(perm_vector)
    return perm_vector


def generate_opcode_vector(dictOpCodes, ALL_OPECODES):
    opcode_vec = []
    for opcode in ALL_OPECODES:
        try:
            opcode_vec.append(dictOpCodes[opcode])
        except Exception as err:
            opcode_vec.append(0)
            # print(err)
    return opcode_vec


def generate_opstrings_vector(dictOpStrings, ALL_STRINGS):
    opstring_vec = []
    for opstring in ALL_STRINGS:
        try:
            opstring_vec.append(dictOpStrings[opstring])
        except Exception as err:
            opstring_vec.append(0)
            # print(err)
    return opstring_vec


with open('data.json', 'r') as jsonFile:
    data = json.load(jsonFile)

# generating all opcodes
for datarow in data:
    ALL_OPECODES += list(datarow['Opcodes'].keys())
    print(len(ALL_OPECODES))

ALL_OPECODES = sorted(list(set(ALL_OPECODES)))
print('TOTAL OPCODES ' + str(len(ALL_OPECODES)))

# genrating all strings
for datarow in data:
    ALL_STRINGS += list(datarow['Strings'].keys())
    print(len(ALL_STRINGS))

ALL_STRINGS = sorted(list(set(ALL_STRINGS)))
print('TOTAL ALL_STRINGS ' + str(len(ALL_STRINGS)))

pdArr = []
scan_columns = []
appendCols = True
for i in range(len(data)):
    datarow = data[i]
    permission_vec = get_permission_matrix(datarow['Permissions'])
    print(permission_vec)
    opcode_vec = generate_opcode_vector(datarow['Opcodes'], ALL_OPECODES)
    print(opcode_vec)
    opstring_vec = generate_opstrings_vector(datarow['Strings'], ALL_STRINGS)
    print(opstring_vec)

    dictVector = {}
    dictVector['Permissions'] = permission_vec
    dictVector['Opcodes'] = opcode_vec
    dictVector['Strings'] = opstring_vec
    dictVector['VersionCode'] = datarow['VersionCode']
    dictVector['isMalware'] = int(datarow['malware'])
    dictVector['sha1'] = str(datarow['sha1'])

    """We did not use VT due to lack of time"""
    # vt_json = json.load(open('VT_ANALYSIS/test.json'))  # to append key value

    # try:
    #     #appedning virus info
    #     for scanInfo in vt_json['scans']:
    #         dictVector[str(scanInfo)] = int(datarow[scanInfo])
    #         if appendCols: scan_columns.append(str(scanInfo))

    #     dictVector['vt_total'] = datarow['vt_total']
    #     dictVector['vt_positives'] = datarow['vt_positives']
    # except Exception as err:
    #     #appedning virus info for not available
    #     for scanInfo in vt_json['scans']:
    #         dictVector[str(scanInfo)] = int(datarow['malware'])

    #     dictVector['vt_total'] = 0
    #     dictVector['vt_positives'] = 0
    #     print(err)

    appendCols = False
    pdArr.append(dictVector)

    scan_columns.append('Permissions')
    scan_columns.append('Opcodes')
    scan_columns.append('Strings')
    scan_columns.append('VersionCode')
    # scan_columns.append('vt_total')
    # scan_columns.append('vt_positives')
    scan_columns.append('isMalware')

df = pd.DataFrame(pdArr, columns=list(set(scan_columns)), dtype=np.float32)
print(df.head())

# df.to_csv('dataframe.csv', index=None, header=True)

y = np.asarray(list(df['isMalware']))
del df['isMalware']


Xp = np.asarray(list(df['Permissions']))
Xo = np.asarray(list(df['Opcodes']))
Xs = np.asarray(list(df['Strings']))

# X = [Xp + Xo + Xs]
X = np.concatenate((Xp, Xo), 1)
X = np.concatenate((X, Xs), 1)

del df['Permissions'], df['Opcodes'], df['Strings']


X = np.concatenate((X, df.values), 1)

from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score

xTrain, xTest, yTrain, yTest = train_test_split(X, y, test_size=0.2, random_state=0, shuffle=True)
np.save('result/xTest', xTest)
np.save('result/yTest', yTest)
np.save('result/xTrain', xTrain)
np.save('result/yTrain', yTrain)
# Create and train the model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(xTrain, yTrain)
score = str(knn.score(xTest, yTest))
print('KNeighborsClassifier Score ' + score)

import pickle
pickle.dump(knn, open('result/knn.sav', 'wb'))

# Create and train the model
clf = RandomForestClassifier(n_estimators=100, random_state=0)
clf.fit(xTrain, yTrain)
score = str(clf.score(xTest, yTest))
print('RandomForestClassifier Score ' + score)
pickle.dump(clf, open('result/clf.sav', 'wb'))

rclf = DecisionTreeClassifier(max_depth=20, random_state=0)
rclf.fit(xTrain, yTrain)
score = str(rclf.score(xTest, yTest))
print('DecisionTreeClassifier Score ' + score)
pickle.dump(rclf, open('result/rclf.sav', 'wb'))

eclf2 = VotingClassifier(estimators=[('knn', knn), ('adaboost', clf), ('rf', rclf)], voting='soft')
eclf2.fit(xTrain, yTrain)
score = str(eclf2.score(xTest, yTest))
print('VotingClassifier Score ' + score)
pickle.dump(eclf2, open('result/eclf2.sav', 'wb'))
